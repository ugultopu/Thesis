As it can be expected, the development process for this programmatic content generator wasn't all smooth sailing. I have encountered some problems which I have solved with altering the algorithm or adding more steps to it. Some of these problems that I have encountered and the solution to them are as follows:

1. Orientation of the scalable vector graphics image: The programmatic content generator is originally designed to work with a scalable vector graphics image as the input. That is, the scalable vector graphics image would represent the outlines of the structure that is going to form the basis for the level. The programmatic content generator would:

  1. Take this scalable vector graphics image as input.
  2. Parse the `<polygon>` element out of it.
  3. From the cartesian points specified in the `<polygon>` element, construct a polygon using Shapely library.
  4. Using this constructed polygon, find places to insert blocks, platforms and enemies.
  5. Output the level in the extensible markup language format.

However, after changing the program to convert a raster image to a Science Birds level, we have observed a peculiarity in the output. Now, the program would work as follows:

  1. Take a raster image as input.
  2. Convert this raster image to black-and-white.
  3. Denoise this black-and-white image.
  4. Vectorize this denoised black-and-white image using Potrace.
  5. Feed the Potrace output into the programmatic content generator to get a Science Birds structure and to obtain it as a Science Birds level in extensible markup language format.

The peculiarity that we are talking about occurs in step number 4 of this process. When Potrace traces an image, for some reason, it generates the output in upside-down format. That is, when we feed the scalable vector graphics image that is generated by Potrace into the programmatic content generator, the structure in each generated level was all upside-down. After examining the extensible markup language source of the generated levels, I have discovered that Potrace indeed declares a `<polygon>` in upside down format and ensures its upright rendering using the "scale" function of the "transform" attribute of scalable vector graphics on the `<polygon>` element.

2. Insertion of the platform blocks in order to prevent hanging primary blocks from free falling: We insert platform blocks in order to support primary blocks and prevent them from free falling. Initially, the platform block insertion considered only the primary blocks that didn't have anything underneath them. That is, if a primary block in row index N didn't have anything underneath, then we would insert a platform block just to cover that primary block. The rest of the primary blocks on row index N would be left as is. That is, those blocks wouldn't have any platform blocks inserted underneath. Although this initially seems like a sound approach, upon creating a few levels with and observing the results, it becomes clear that this approach has a consequence that would lead to a couple problems. The consequence is the following: Inserting a platform block under one section of a row and leaving the rest of the sections of that row empty results in a skew. That is, doing that elevates one side of the structure, due to the height of the inserted platform block, and leaves the other side of the structure without elevation. The problem with this skew is that before inserting any blocks, every primary block would be horizontally aligned. That is, before inserting any blocks, every primary block in a row would start at the same vertical distance from the ground and hence, end at the same vertical distance from the ground. This makes it easy for a lot of cases, such as not having to think about the cases where inserting another platform block that might correspond to a skewed place. In such case, inserting a platform block to a skewed location result in imbalances and as a result of this, it makes the structure more likely to topple down.

TODO Insert a screenshot here to demonstrate what I mean

3. Insertion of platform blocks on specific places on a row: As described, the algorithm to insert platform blocks on a given row is as follows:

  1. Find the first primary block and the last primary block on the row and get their column indices.
  2. Using these column indices, find the distance between them.
  3. Start inserting platform blocks from the center of this distance. If the number of platform blocks that are required to cover this distance is an even number, insert two blocks would 
